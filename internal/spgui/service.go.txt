package spgui

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/koltyakov/gosip"
	"github.com/wailsapp/wails/v2/pkg/runtime"

	"github.com/vba-excel/spapi"
	edgeondemand "github.com/vba-excel/sp-edgeondemand"
)

type Config struct {
	ConfigPath string // ex.: "private.json"
	SiteURL    string // override opcional
}

type SPGUI struct {
	cfg   Config
	svc   *spapi.SPService
	spcli *gosip.SPClient
	ctx   context.Context // contexto do Wails para diálogos, etc.
}

func NewSPGUI(cfg Config) *SPGUI { return &SPGUI{cfg: cfg} }

// Guardar o contexto do Wails (chamado em OnStartup)
func (g *SPGUI) SetContext(ctx context.Context) { g.ctx = ctx }

// Permite trocar config em runtime a partir do GUI
func (g *SPGUI) SetConfig(cfg Config) {
	g.cfg = cfg
	g.svc = nil
	g.spcli = nil
}

// ===== DTOs =====

type ListQuery struct {
	ListName   string `json:"list"`
	Select     string `json:"select"`
	Filter     string `json:"filter"`
	OrderBy    string `json:"orderby"`
	Top        int    `json:"top"`
	All        bool   `json:"all"`
	LatestOnly bool   `json:"latestOnly"`
}

type QuerySummary struct {
	Items        int  `json:"items"`
	PagesFetched int  `json:"pages"`
	Throttled    bool `json:"throttled"`
	Partial      bool `json:"partial"`
	UsedFallback bool `json:"fallback"`
	StoppedEarly bool `json:"stoppedEarly"`
}

type ListResponse struct {
	Items   []map[string]any `json:"items"`
	Summary QuerySummary     `json:"summary"`
}

// ===== Métodos expostos =====

func (g *SPGUI) Ping() string { return "ok" }

// Abre um diálogo nativo para escolher o private.json (feito no backend)
func (g *SPGUI) OpenConfigDialog() (string, error) {
	if g.ctx == nil {
		return "", fmt.Errorf("runtime context indisponível")
	}
	path, err := runtime.OpenFileDialog(g.ctx, runtime.OpenDialogOptions{
		Title: "Escolher private.json",
		Filters: []runtime.FileFilter{
			{DisplayName: "JSON", Pattern: "*.json"},
		},
	})
	return path, err
}

func (g *SPGUI) ListItems(q ListQuery) (*ListResponse, error) {
	if err := g.ensureService(); err != nil {
		return nil, err
	}
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	items, stats, err := g.svc.ListItems(ctx, spapi.ListQueryOptions{
		ListName:   q.ListName,
		Select:     q.Select,
		Filter:     q.Filter,
		OrderBy:    q.OrderBy,
		Top:        q.Top,
		All:        q.All,
		LatestOnly: q.LatestOnly,
	})
	if err != nil {
		return nil, err
	}
	return &ListResponse{
		Items: items,
		Summary: QuerySummary{
			Items:        len(items),
			PagesFetched: stats.PagesFetched,
			Throttled:    stats.Throttled,
			Partial:      stats.Partial,
			UsedFallback: stats.UsedFallback,
			StoppedEarly: stats.StoppedEarly,
		},
	}, nil
}

func (g *SPGUI) GetItem(list string, id int, selectFields string) (map[string]any, error) {
	if err := g.ensureService(); err != nil {
		return nil, err
	}
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	return g.svc.GetItemByID(ctx, list, id, selectFields)
}

func (g *SPGUI) AddItem(list string, fields map[string]any, selectFields string) (map[string]any, error) {
	if err := g.ensureService(); err != nil {
		return nil, err
	}
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()
	created, err := g.svc.AddItem(ctx, list, fields)
	if err != nil {
		return nil, err
	}
	id := extractIDFromMap(created)
	if id <= 0 {
		return created, nil
	}
	return g.svc.GetItemByID(ctx, list, id, selectFields)
}

func (g *SPGUI) UpdateItem(list string, id int, fields map[string]any, selectFields string) (map[string]any, error) {
	if err := g.ensureService(); err != nil {
		return nil, err
	}
	if id <= 0 {
		return nil, fmt.Errorf("id inválido")
	}
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()
	if _, err := g.svc.UpdateItem(ctx, list, id, fields); err != nil {
		return nil, err
	}
	return g.svc.GetItemByID(ctx, list, id, selectFields)
}

func (g *SPGUI) DeleteItem(list string, id int) (bool, error) {
	if err := g.ensureService(); err != nil {
		return false, err
	}
	if id <= 0 {
		return false, fmt.Errorf("id inválido")
	}
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	if err := g.svc.DeleteItem(ctx, list, id); err != nil {
		return false, err
	}
	return true, nil
}

// Pretty JSON (útil para debug no GUI)
func (g *SPGUI) JSON(v any) string {
	b, _ := json.MarshalIndent(v, "", "  ")
	return string(b)
}

// ===== Internos =====

func (g *SPGUI) ensureService() error {
	if g.svc != nil {
		return nil
	}
	if g.cfg.ConfigPath == "" {
		g.cfg.ConfigPath = "private.json"
	}

	auth := &edgeondemand.AuthCnfg{}
	if err := auth.ReadConfig(g.cfg.ConfigPath); err != nil {
		return fmt.Errorf("ler %s: %w", g.cfg.ConfigPath, err)
	}
	if g.cfg.SiteURL != "" {
		auth.SiteURL = g.cfg.SiteURL
	}
	if auth.EdgeOptions == nil {
		auth.EdgeOptions = &edgeondemand.EdgeConfig{}
	}
	effectiveTimeout := 30 * time.Second
	if auth.EdgeOptions.TimeoutSeconds > 0 {
		effectiveTimeout = time.Duration(auth.EdgeOptions.TimeoutSeconds) * time.Second
	}

	httpTransport := &http.Transport{
		Proxy:                 http.ProxyFromEnvironment,
		TLSHandshakeTimeout:   10 * time.Second,
		MaxIdleConns:          100,
		IdleConnTimeout:       90 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
	}
	spHTTPClient := http.Client{
		Timeout:   effectiveTimeout,
		Transport: httpTransport,
	}
	client := &gosip.SPClient{
		Client:     spHTTPClient,
		AuthCnfg:   auth,
		ConfigPath: g.cfg.ConfigPath,
	}
	g.spcli = client
	g.svc = spapi.New(client)
	return nil
}

func extractIDFromMap(m map[string]any) int {
	for _, k := range []string{"ID", "Id", "id"} {
		if v, ok := m[k]; ok {
			switch vv := v.(type) {
			case int:
				return vv
			case int32:
				return int(vv)
			case int64:
				return int(vv)
			case float32:
				return int(vv)
			case float64:
				return int(vv)
			}
		}
	}
	return 0
}
